// Generated by vproto - Do not modify
module vproto_test

import emily33901.vproto

pub struct PersonPhoneNumberComment {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	comment        string
}

pub fn new_personphonenumbercomment() PersonPhoneNumberComment {
	return PersonPhoneNumberComment{}
}

pub fn (o &PersonPhoneNumberComment) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_string_field(o.comment, 1)
	return res
}

pub fn (mut res personphonenumbercomment) unpack(buf []byte) ?PersonPhoneNumberComment {
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.comment = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn pack_personphonenumbercomment(o PersonPhoneNumberComment, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn unpack_personphonenumbercomment(buf []byte, tag_wiretype vproto.WireType) (int, PersonPhoneNumberComment) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := personphonenumbercomment_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct PersonPhoneNumber {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	number         string
	type           PersonPhoneType
	has_type       bool
	comment        PersonPhoneNumberComment
	has_comment    bool
}

pub fn new_personphonenumber() PersonPhoneNumber {
	return PersonPhoneNumber{}
}

pub fn (o &PersonPhoneNumber) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_string_field(o.number, 1)
	if o.has_type {
		res << pack_personphonetype(o.type, 2)
	}
	if o.has_comment {
		res << pack_personphonenumbercomment(o.comment, 3)
	}
	return res
}

pub fn (mut res personphonenumber) unpack(buf []byte) ?PersonPhoneNumber {
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.number = v
				i = ii
			}
			2 {
				res.has_type = true
				ii, v := unpack_personphonetype(cur_buf, tag_wiretype.wire_type)
				res.type = v
				i = ii
			}
			3 {
				res.has_comment = true
				ii, v := unpack_personphonenumbercomment(cur_buf, tag_wiretype.wire_type)
				res.comment = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn pack_personphonenumber(o PersonPhoneNumber, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn unpack_personphonenumber(buf []byte, tag_wiretype vproto.WireType) (int, PersonPhoneNumber) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := personphonenumber_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

[_allow_multiple_values]
enum PersonPhoneType {
	mobile = 0
	home = 1
	work = 2
}

// FOR INTERNAL USE ONLY
fn pack_personphonetype(e PersonPhoneType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn unpack_personphonetype(buf []byte, tag_wiretype vproto.WireType) (int, PersonPhoneType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)
	return i, PersonPhoneType(v)
}

pub struct Person {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	id             int
	email          string
	has_email      bool
	phone          []PersonPhoneNumber
}

pub fn new_person() Person {
	return Person{}
}

pub fn (o &Person) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_string_field(o.name, 1)
	res << vproto.pack_int32_field(o.id, 2)
	if o.has_email {
		res << vproto.pack_string_field(o.email, 3)
	}
	// [packed=false]
	for _, x in o.phone {
		res << pack_personphonenumber(x, 4)
	}
	return res
}

pub fn (mut res person) unpack(buf []byte) ?Person {
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.id = v
				i = ii
			}
			3 {
				res.has_email = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.email = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := unpack_personphonenumber(cur_buf, tag_wiretype.wire_type)
				res.phone << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn pack_person(o Person, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn unpack_person(buf []byte, tag_wiretype vproto.WireType) (int, Person) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := person_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct LookupResult {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	person         Person
	has_person     bool
}

pub fn new_lookupresult() LookupResult {
	return LookupResult{}
}

pub fn (o &LookupResult) pack() []byte {
	mut res := []byte{}
	if o.has_person {
		res << pack_person(o.person, 1)
	}
	return res
}

pub fn (mut res lookupresult) unpack(buf []byte) ?LookupResult {
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_person = true
				ii, v := unpack_person(cur_buf, tag_wiretype.wire_type)
				res.person = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn pack_lookupresult(o LookupResult, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn unpack_lookupresult(buf []byte, tag_wiretype vproto.WireType) (int, LookupResult) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := lookupresult_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct Name {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
}

pub fn new_name() Name {
	return Name{}
}

pub fn (o &Name) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	return res
}

pub fn (mut res name) unpack(buf []byte) ?Name {
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn pack_name(o Name, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn unpack_name(buf []byte, tag_wiretype vproto.WireType) (int, Name) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := name_unpack(v) or {
		panic('')
	}
	return i, unpacked
}
